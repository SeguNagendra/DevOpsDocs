Docker is an **open-source platform** that allows you to **build, package, ship, and run applications** inside **containers**. Containers are lightweight, portable, and self-sufficient environments that include **everything your application needs** ‚Äî code, runtime, system tools, libraries, and dependencies ‚Äî so it can run **consistently across different environments**.

Let me break it down in a **very simple way**:

**1\. What Docker Does**
------------------------

Docker solves the classic developer problem:

> _‚ÄúIt works on my machine, but not on the server!‚Äù_ üòÖ

With Docker, you package your app **with all its dependencies** into a container ‚Üí move it anywhere ‚Üí and it **runs the same way** everywhere, whether on your laptop, a testing server, or in the cloud.

**2\. Key Concepts in Docker**

**ComponentDescriptionExampleImage**A **read-only template** that contains your app + environmentnginx:latest**Container**A **running instance** of an imageYour running Nginx server**Dockerfile**A script with instructions to **build an image**FROM ubuntu:20.04**Docker Engine**The core service that **runs containers**Installed when you install Docker**Docker Hub**A public **registry** to store and share imageshub.docker.com

**3\. How Docker Works**
------------------------

Think of Docker as a **shipping container system** for software:

*   Traditionally, apps run on **different environments** ‚Üí dependency issues arise.
*   Docker **isolates your app** in a container ‚Üí it always works the same.
*   Containers **share the OS kernel**, making them **faster & lighter** than virtual machines.
    

**Example Workflow**:

```YAMLXML
# Pull an image from Docker Hub  
docker pull nginx  
# Run a container from that image  
docker run -d -p 8080:80 nginx  
# Check running containers  
docker ps   `
```
This starts an **Nginx web server** on port **8080** in just seconds.

**4\. Docker vs Virtual Machines**
----------------------------------

**FeatureDocker (Containers)Virtual MachinesStartup Time**SecondsMinutes**Resource Usage**LightweightHeavy**Isolation**Process-levelFull OS-level**Portability**HighMedium**Size**MBsGBs

**5\. Why Docker is Popular**
-----------------------------

*   üöÄ **Speed** ‚Üí Start apps in seconds
*   üõ†Ô∏è **Consistency** ‚Üí Runs the same everywhere
*   üß© **Isolation** ‚Üí No conflicts between apps
*   üåç **Portability** ‚Üí Works on any machine
*   üì¶ **Scalability** ‚Üí Perfect for **microservices** and **cloud deployments**
    

**6\. Real-Life Example**
-------------------------

Imagine you‚Äôre developing a **Java web app**:

*   Without Docker ‚Üí You install Java, Tomcat, MySQL, dependencies manually.
*   docker run -d -p 8080:8080 tomcatdocker run -d -p 3306:3306 mysqlBoth Tomcat and MySQL are **ready in seconds**, no setup headaches.
    

**7\. Simple Diagram**
----------------------

+-------------------------------------+
|          Your Application          |
|   (Code + Libraries + Config)      |
+-------------------------------------+
|        Docker Container            |
+-------------------------------------+
|      Docker Engine / Daemon        |
+-------------------------------------+
|      Host OS & Hardware           |
+-------------------------------------+

**Summary**
-----------

*   Docker = Platform to **build, run, and ship apps** in containers.
*   Containers = Lightweight, isolated environments.
*   Docker ensures **consistency, speed, portability**, and **scalability**.
*   Ideal for **developers, testers, DevOps, and cloud deployments**.
    
**üê≥ Docker Components ‚Äì Complete Guide**
-----------------------------------------

Docker is built on a set of components that work together to **build, run, manage, and distribute containers**.These components are:

**üìå Docker Components Overview**
=================================

| **Component**                    | **Description**                                                                                                           | **Example / Use Case**                     |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------ |
| **1. Docker Engine**             | The **core service** that runs and manages Docker containers. It consists of the **Docker Daemon**, **API**, and **CLI**. | Starts, stops, and manages containers.     |
| **2. Docker Daemon (`dockerd`)** | Background process responsible for managing images, containers, networks, and volumes.                                    | Listens for Docker commands from CLI/API.  |
| **3. Docker CLI (`docker`)**     | Command-line interface used to interact with Docker.                                                                      | `docker run nginx`                         |
| **4. Docker Images**             | A **read-only template** used to create containers. Contains the app + environment + dependencies.                        | `nginx`, `mysql`, `ubuntu` images          |
| **5. Docker Containers**         | **Running instances** of Docker images. Lightweight and isolated.                                                         | `docker run -d nginx`                      |
| **6. Docker Hub / Registry**     | Cloud-based repository to **store and share images**.                                                                     | `docker pull nginx`                        |
| **7. Dockerfile**                | A text file containing **instructions** to build a Docker image.                                                          | Uses `FROM`, `RUN`, `COPY`, `CMD` commands |
| **8. Docker Compose**            | A tool to define and run **multi-container applications** using a `docker-compose.yml` file.                              | `docker-compose up`                        |
| **9. Docker Volumes**            | Used to **store persistent data** outside containers.                                                                     | `docker volume create myvolume`            |
| **10. Docker Networking**        | Enables **communication** between containers and between containers & the outside world.                                  | `docker network create mynet`              |


**üîπ Detailed Explanation of Components**
-----------------------------------------

### **1Ô∏è‚É£ Docker Engine**

*   **Core part** of Docker.
    
*   Client-server architecture:
    
    *   **Docker Daemon** ‚Üí Handles heavy lifting (builds, runs, manages containers).
    *   **REST API** ‚Üí Interface between CLI and Daemon.
    *   **Docker CLI** ‚Üí Sends commands to Daemon.
        
*   **Example:**
    
    ```bash
    docker run nginx
    ```

*   Here, the CLI sends a request ‚Üí Daemon pulls the image ‚Üí Creates & starts a container.
    

### **2Ô∏è‚É£ Docker Daemon (dockerd)**

*   A **background service** that manages:
    *   Images
    *   Containers
    *   Networks
    *   Volumes
*   Listens for **Docker API requests** and handles them.
*   Starts automatically when you start Docker.
    

### **3Ô∏è‚É£ Docker CLI**

*   A **command-line tool** to interact with Docker.
*   Examples:
    ```YAMLXML 
    docker ps            # List running containers  
    docker images        # List downloaded images  
    docker run nginx     # Run a container from nginx image 
    ```

### **4Ô∏è‚É£ Docker Images**

*   **Templates** used to create containers.
*   Built using **Dockerfile**.
*   Stored locally or on **Docker Hub**.
*   **Example:**
    ```YAMLXML
    docker pull ubuntu  docker images   
    ````

### **5Ô∏è‚É£ Docker Containers**

*   A **running instance** of an image.
*   Lightweight and **isolated** from other containers.
*   Can start, stop, pause, and remove containers.
*   **Example:**
    

```YAMLXML
docker run -d --name myweb nginx  
docker ps
```

### **6Ô∏è‚É£ Docker Hub / Registry**

*   A **cloud-based repository** where Docker images are stored.
*   You can:
    *   **Pull images** from Docker Hub.
    *   **Push your custom images** to share.
        
*   **Example:**
    ```YAMLXML   
    docker pull mysql  docker push myrepo/myimage   `
    ```
### **7Ô∏è‚É£ Dockerfile**

*   A simple text file containing **instructions** to build an image.
*   Example Dockerfile:
    ```YAMLXML
    FROM ubuntu:20.04
    RUN apt-get update && apt-get install -y nginx
    COPY index.html /var/www/html
    CMD ["nginx", "-g", "daemon off;"]   `
    ```
*   Build the image:
    ```YAMLXML   
    docker build -t mynginx .   `
    ```
### **8Ô∏è‚É£ Docker Compose**

*   Used to **manage multi-container applications**.
*   Uses a docker-compose.yml file.
    
*   **Example:**
```YML 
version: "3"
services:
  web:
    image: nginx
    ports:
      - "8080:80"
  db:
    image: mysql
```
*   Run everything:
    `   docker-compose up -d   `

### **9Ô∏è‚É£ Docker Volumes**

*   Persistent storage solution for containers.
*   Keeps data **even if the container is deleted**.
*   **Example:**
       ```
        docker volume create mydata  
        docker run -v mydata:/app/data nginx 
    ```
### **üîü Docker Networking**

*   Allows containers to **communicate** with each other and the host machine.
*   Types of networks:
    *   **bridge** ‚Üí Default network.
    *   **host** ‚Üí Shares host network.
    *   **overlay** ‚Üí For multi-host setups.
        
*   **Example:**
    ```YAMLXML   
    docker network create mynet  
    docker run -d --net=mynet nginx   
    ```

**üìå Docker Components Summary Table**
--------------------------------------

| **Component**     | **Purpose**                          | **Example Command**          |
| ----------------- | ------------------------------------ | ---------------------------- |
| Docker Engine     | Core part of Docker, runs everything | `systemctl start docker`     |
| Docker Daemon     | Manages containers, images, volumes  | Runs in background           |
| Docker CLI        | Command-line interface               | `docker ps`                  |
| Docker Images     | Templates to create containers       | `docker pull ubuntu`         |
| Docker Containers | Running instances of images          | `docker run nginx`           |
| Docker Hub        | Cloud registry for images            | `docker pull mysql`          |
| Dockerfile        | Instructions to build images         | `docker build -t app .`      |
| Docker Compose    | Manage multi-container apps          | `docker-compose up`          |
| Docker Volumes    | Persistent storage for containers    | `docker volume create myvol` |
| Docker Networking | Communication between containers     | `docker network ls`          |


**‚úÖ Summary**
-------------

*   **Docker Engine** ‚Üí Core service.
*   **Docker Images** ‚Üí Templates.
*   **Docker Containers** ‚Üí Running apps.
*   **Docker Volumes** ‚Üí Persistent storage.
*   **Docker Networking** ‚Üí Communication.
*   **Docker Compose** ‚Üí Multi-container orchestration.
*   **Docker Hub** ‚Üí Image repository.
    

**üê≥ Docker Images & Containers ‚Äì Complete Guide**

**üîπ What is a Docker Image?**
------------------------------

A **Docker Image** is a **lightweight, read-only template** that contains:

*   Application code
*   Runtime environment
*   Dependencies
*   Libraries
*   Configuration files
   

Docker uses images to create **containers**.You can think of an **image** as a **blueprint** for running applications.

### **Key Points**

*   Stored locally or on registries like **Docker Hub**.
*   Built using a **Dockerfile**.
*   **Immutable** ‚Üí Images cannot be changed once created.
*   Multiple containers can be created from the same image.
    

**Example:**

```YAMLXML   
    docker pull nginx  
    docker images   
 ```

**üîπ What is a Docker Container?**
----------------------------------

A **Docker Container** is a **running instance of a Docker image**.It‚Äôs where your application actually runs.

### **Key Points**

*   Lightweight and isolated.
*   Uses the image as a base but can have its own changes.
*   Can start, stop, restart, and delete containers.
*   Containers share the host OS kernel but run in **separate environments**.
    

**Example:**

```YAMLXML
docker run -d --name myweb nginx  
docker ps   `
```
**üîπ Difference Between Docker Image & Container**
--------------------------------------------------

| **Feature**         | **Docker Image**                                    | **Docker Container**                      |
| ------------------- | --------------------------------------------------- | ----------------------------------------- |
| **Definition**      | A **read-only template** used to create containers. | A **running instance** of a Docker image. |
| **State**           | Static (cannot be modified).                        | Dynamic (running, stopped, paused).       |
| **Usage**           | Used as a blueprint to launch containers.           | Executes the application.                 |
| **Mutability**      | Immutable ‚Äî cannot be changed after creation.       | Containers can be modified temporarily.   |
| **Persistence**     | Exists until manually deleted.                      | Deleted automatically when removed.       |
| **Command Example** | `docker pull nginx`                                 | `docker run nginx`                        |


**üìå Docker Image Commands**
----------------------------

| **Command**                      | **Description**               | **Example**                        |
| -------------------------------- | ----------------------------- | ---------------------------------- |
| `docker images`                  | List all local images         | `docker images`                    |
| `docker pull <image>`            | Download image from registry  | `docker pull ubuntu`               |
| `docker rmi <image>`             | Remove an image               | `docker rmi nginx`                 |
| `docker tag <image> <repo:tag>`  | Tag an image                  | `docker tag myapp myrepo/myapp:v1` |
| `docker save <image> > file.tar` | Save image to a `.tar` file   | `docker save nginx > nginx.tar`    |
| `docker load < file.tar`         | Load image from `.tar` file   | `docker load < nginx.tar`          |
| `docker inspect <image>`         | Get detailed info about image | `docker inspect nginx`             |
| `docker history <image>`         | Show image build history      | `docker history ubuntu`            |
| `docker search <image>`          | Search images on Docker Hub   | `docker search redis`              |
| `docker prune images`            | Remove all unused images      | `docker image prune`               |


**üìå Docker Container Commands**
--------------------------------

| **Command**                            | **Description**                         | **Example**                       |
| -------------------------------------- | --------------------------------------- | --------------------------------- |
| `docker ps`                            | List **running** containers             | `docker ps`                       |
| `docker ps -a`                         | List **all** containers                 | `docker ps -a`                    |
| `docker run <image>`                   | Run a container from image              | `docker run nginx`                |
| `docker run -d <image>`                | Run container in **detached mode**      | `docker run -d nginx`             |
| `docker run -it <image> /bin/bash`     | Start container with interactive shell  | `docker run -it ubuntu /bin/bash` |
| `docker exec -it <container> bash`     | Access running container shell          | `docker exec -it myweb bash`      |
| `docker logs <container>`              | View logs of a container                | `docker logs myweb`               |
| `docker start <container>`             | Start a stopped container               | `docker start myweb`              |
| `docker stop <container>`              | Stop a running container                | `docker stop myweb`               |
| `docker restart <container>`           | Restart a container                     | `docker restart myweb`            |
| `docker rename <old> <new>`            | Rename a container                      | `docker rename myweb webserver`   |
| `docker rm <container>`                | Remove a container                      | `docker rm myweb`                 |
| `docker inspect <container>`           | Get detailed info                       | `docker inspect myweb`            |
| `docker stats`                         | View container resource usage           | `docker stats`                    |
| `docker top <container>`               | Show running processes inside container | `docker top myweb`                |
| `docker export <container> > file.tar` | Export container to `.tar`              | `docker export myweb > myweb.tar` |
| `docker import file.tar`               | Import container from `.tar`            | `docker import myweb.tar`         |
| `docker container prune`               | Remove all **stopped** containers       | `docker container prune`          |


**üìå Image & Container Commands Summary Table**
-----------------------------------------------

| **Command**     | **Description**          | **Example**                  |
| --------------- | ------------------------ | ---------------------------- |
| `docker images` | List images              | `docker images`              |
| `docker pull`   | Download image           | `docker pull nginx`          |
| `docker rmi`    | Remove image             | `docker rmi nginx`           |
| `docker run`    | Create & start container | `docker run nginx`           |
| `docker ps`     | List running containers  | `docker ps`                  |
| `docker ps -a`  | List all containers      | `docker ps -a`               |
| `docker stop`   | Stop container           | `docker stop myweb`          |
| `docker rm`     | Remove container         | `docker rm myweb`            |
| `docker logs`   | Show container logs      | `docker logs myweb`          |
| `docker exec`   | Access container shell   | `docker exec -it myweb bash` |


**‚úÖ Summary**
-------------

*   **Docker Image** ‚Üí Blueprint/template for creating containers.
*   **Docker Container** ‚Üí Running instance of an image.
*   **Images are immutable**, **containers are mutable**.
*   Docker provides powerful commands to **create, manage, inspect, and delete** images & containers.
    

**üê≥ Docker Volumes ‚Äì Complete Guide**
======================================

**üîπ What is a Docker Volume?**
-------------------------------

A **Docker Volume** is a **persistent storage mechanism** used to store data generated and used by Docker containers. By default, when a container is removed, its data is lost.**Volumes** solve this problem by providing a way to **store, share, and manage data** outside the container‚Äôs writable layer.

### **Why Use Volumes?**

*   Containers are **ephemeral** (data is lost when deleted).
*   Volumes **persist data** even after container removal.
*   Easier to **share data between multiple containers**.
*   Better performance compared to bind mounts.
*   Managed directly by Docker.
    

**Example:**

```YAMLXML
docker run -d -v myvolume:/app/data nginx   `
```
Here:
*   myvolume ‚Üí Docker-managed volume.
*   /app/data ‚Üí Directory inside the container where the data is stored.
    

**üîπ Types of Docker Volumes**
------------------------------

Docker supports **three main types** of volumes:

### **1\. Named Volumes**

*   Explicitly created and managed by Docker.
*   Stored under Docker‚Äôs storage path:**Linux** ‚Üí /var/lib/docker/volumes/**Windows** ‚Üí C:\\ProgramData\\Docker\\volumes\\
*   Recommended for **persistent storage**.
    

**Example:**

```YAMLXML
docker volume create myvolume
docker run -d -v myvolume:/app/data nginx   `
```
### **2\. Anonymous Volumes**

*   Created automatically when you **mount a volume** without giving it a name.
*   Docker assigns a **random name**.
*   Harder to manage because you don‚Äôt know the name unless you list volumes.
*   Best for **temporary storage**.
    

**Example:**

```YAMLXML 
docker run -d -v /app/data nginx   `
```
Here, Docker creates an **unnamed volume** automatically.

### **3\. Bind Mounts**

*   Maps a **specific directory on the host machine** to a container directory.
*   Useful for **development** since changes on the host are instantly visible in the container.
*   **Not managed by Docker** ‚Äî you must manage the directory manually.
    

**Example:**

```YAMLXML
docker run -d -v /home/nagendra/data:/app/data nginx   `
```
Here:

*   /home/nagendra/data ‚Üí Directory on **host machine**.
*   /app/data ‚Üí Mounted directory **inside container**.
    

**üìå Docker Volume Commands**
-----------------------------

| **Command**                               | **Description**                   | **Example**                                     |
| ----------------------------------------- | --------------------------------- | ----------------------------------------------- |
| `docker volume create <name>`             | Create a named volume             | `docker volume create myvolume`                 |
| `docker volume ls`                        | List all volumes                  | `docker volume ls`                              |
| `docker volume inspect <name>`            | View detailed info about a volume | `docker volume inspect myvolume`                |
| `docker volume rm <name>`                 | Remove a specific volume          | `docker volume rm myvolume`                     |
| `docker volume prune`                     | Remove **all unused volumes**     | `docker volume prune`                           |
| `docker run -v <vol>:/path`               | Mount volume to container         | `docker run -v myvolume:/app/data nginx`        |
| `docker run -v /host:/container`          | Bind mount host directory         | `docker run -v /home/user/data:/app/data nginx` |
| `docker volume rm $(docker volume ls -q)` | Delete **all volumes**            | `docker volume rm $(docker volume ls -q)`       |


**üìå Quick Comparison ‚Äì Named vs Bind Mounts**
----------------------------------------------

| **Feature**     | **Named Volume**                      | **Bind Mount**        |
| --------------- | ------------------------------------- | --------------------- |
| **Location**    | Managed by Docker (`/var/lib/docker`) | On host machine       |
| **Creation**    | Created using Docker commands         | Manually created      |
| **Performance** | Faster (optimized by Docker)          | Slower if large files |
| **Backup**      | Easy with Docker commands             | Manual                |
| **Portability** | Highly portable                       | Tied to host          |
| **Best For**    | Production storage                    | Local development     |


**üîπ How Many Volumes Can We Create in Docker?**
------------------------------------------------

*   **Docker does not have a hard limit** on the number of volumes.
*   You can create **thousands of volumes** as long as:
    *   You have **enough disk space**.
    *   Your operating system supports the underlying filesystem.
*   /var/lib/docker/volumes/
*   Practically, the limit depends on:
    *   **Available disk space**.
    *   **Inode limits** on the filesystem.
    *   **Performance constraints** if too many volumes are mounted at once.
        

**Example ‚Äî Creating 1000 Volumes:**

```bash
for i in {1..1000}; do docker volume create vol_$i; done  
docker volume ls | wc -l   
```

**üìå Docker Volumes Summary Table**
-----------------------------------

| **Command**                   | **Description**         | **Example**                            |
| ----------------------------- | ----------------------- | -------------------------------------- |
| `docker volume create myvol`  | Create named volume     | `docker volume create myvol`           |
| `docker volume ls`            | List all volumes        | `docker volume ls`                     |
| `docker volume inspect myvol` | Inspect a volume        | `docker volume inspect myvol`          |
| `docker volume rm myvol`      | Remove a volume         | `docker volume rm myvol`               |
| `docker volume prune`         | Remove unused volumes   | `docker volume prune`                  |
| `docker run -v myvol:/data`   | Use volume in container | `docker run -v myvol:/data nginx`      |
| `docker run -v /host:/ctn`    | Bind mount a host dir   | `docker run -v /home/user:/data nginx` |


**‚úÖ Summary**
-------------

*   **Docker Volumes** store **persistent data** for containers.
*   **Three types**
    1.  **Named Volumes** ‚Üí Best for production.
    2.  **Anonymous Volumes** ‚Üí Temporary use.
    3.  **Bind Mounts** ‚Üí Ideal for development.

*   Use docker volume commands to **create, manage, and delete** volumes.
*   **No fixed limit** on the number of volumes ‚Äî it depends on **disk space** and **OS constraints**.

**üê≥ Creating and Attaching Volumes After a Container is Running**
**1\. Create a Volume Anytime**
-------------------------------

You can **create a volume** even after the container is up and running.

```YAMLXML
docker volume create myvolume  
```

This creates a new volume named **myvolume**.

**2\. Can We Attach It Directly to a Running Container?**
---------------------------------------------------------

**No**, Docker does **not** allow attaching a **new volume** directly to an already running container.Volumes must be defined **at the time of container creation** using the -v or --mount option.

For example, if you started a container like this:

```YAMLXML
docker run -d --name myapp nginx   `
```
And later you run:

```YAMLXML
docker run -d -v myvolume:/app/data nginx 
```

It **creates a new container**, not modify the existing one.

**3\. The Correct Way to Add a Volume to an Existing Container**
----------------------------------------------------------------

There are **two main approaches**:

### **Approach 1 ‚Äî Stop, Remove, and Recreate Container (Recommended ‚úÖ)**

Since Docker containers are **stateless** by design, the best way is to:

1.  docker stop myapp
2.  docker rm myapp
3.  docker run -d --name myapp -v myvolume:/app/data nginx
    

This is the **cleanest and safest** approach.

### **Approach 2 ‚Äî Use docker cp Instead of a Volume (Workaround)**

If you only want to **copy files into or from the running container**, you can use:

*   docker cp myfile.txt myapp:/app/data/
*   docker cp myapp:/app/data/myfile.txt .

    
This won‚Äôt mount a volume but lets you move data in/out **without recreating the container**.

**4\. Alternative: Use Docker Compose for Dynamic Volume Management**
---------------------------------------------------------------------

If you're using **Docker Compose**, you can modify the docker-compose.yml file, add the volume, and then run:

```YAMLXML
docker-compose up -d   `
```
Docker will recreate the container with the new volume attached **without affecting other configurations**.

**5\. Summary Table**
---------------------

| **Action**                               | **Possible?** | **Command / Solution**       | **Recommended?**                |
| ---------------------------------------- | ------------- | ---------------------------- | ------------------------------- |
| Create a volume after container starts   | ‚úÖ Yes         | `docker volume create myvol` | ‚úÖ                               |
| Attach a volume to **running** container | ‚ùå No          | Not supported                | ‚ùå                               |
| Recreate container with volume           | ‚úÖ Yes         | `docker run -v myvol:/path`  | ‚úÖ Best                          |
| Copy files instead of using volume       | ‚úÖ Yes         | `docker cp src dest`         | ‚ö° Quick fix                     |
| Use Docker Compose for volume changes    | ‚úÖ Yes         | Update `docker-compose.yml`  | ‚úÖ Good for multi-container apps |

**Final Answer**
----------------

*   **You can create a volume anytime.** ‚úÖ
*   **You cannot directly attach it to a running container.** ‚ùå
*   **Solution:** Stop ‚Üí Remove ‚Üí Recreate container **with the volume** OR use docker cp if you just need to transfer data.
    

**1\. What is a Dockerfile?**

A **Dockerfile** is a **text file** that contains a set of instructions used to **build a Docker image**.When you run docker build, Docker **reads the Dockerfile line by line** and creates an image step by step.

**Think of it like a recipe** üç≤ ‚Üí It tells Docker:
*   Which **base image** to use
*   What **dependencies** to install
*   Which **files** to copy
*   What **commands** to run
*   Which **ports** to expose
*   Which **command** to start when the container runs
    

**2\. Common Instructions Inside a Dockerfile**
-----------------------------------------------


| **Instruction** | **Purpose**                                                 | **Example**                                     |
| --------------- | ----------------------------------------------------------- | ----------------------------------------------- |
| **FROM**        | Defines the **base image** to start from                    | `FROM ubuntu:20.04`                             |
| **LABEL**       | Adds metadata like author or version                        | `LABEL maintainer="nagendra@example.com"`       |
| **RUN**         | Runs commands **while building** the image                  | `RUN apt-get update && apt-get install -y curl` |
| **COPY**        | Copies files **from host ‚Üí container**                      | `COPY index.html /usr/share/nginx/html/`        |
| **ADD**         | Similar to COPY but also handles **remote URLs & archives** | `ADD https://example.com/file.tar.gz /app/`     |
| **WORKDIR**     | Sets the **working directory** inside the container         | `WORKDIR /app`                                  |
| **ENV**         | Sets environment variables                                  | `ENV APP_ENV=production`                        |
| **EXPOSE**      | Exposes a **port** for the container                        | `EXPOSE 8080`                                   |
| **CMD**         | Default command **when the container starts**               | `CMD ["npm", "start"]`                          |
| **ENTRYPOINT**  | Like CMD but **fixed** ‚Äî always executed                    | `ENTRYPOINT ["python3", "app.py"]`              |
| **VOLUME**      | Creates a mount point for persistent storage                | `VOLUME ["/data"]`                              |


**3\. Example Dockerfile**
--------------------------

Let's create a simple **Node.js web application Dockerfile**.

### **Dockerfile**

#### Step 1: Use a base image
FROM node:18

#### Step 2: Add metadata
LABEL maintainer="nagendra@example.com"

#### Step 3: Set working directory inside container
WORKDIR /app

#### Step 4: Copy package files first for caching
COPY package*.json ./

#### Step 5: Install dependencies
RUN npm install

#### Step 6: Copy the remaining source code
COPY . .

#### Step 7: Expose the port the app runs on
EXPOSE 3000

#### Step 8: Define environment variable
ENV NODE_ENV=production

#### Step 9: Run the application
CMD ["npm", "start"]
 `

**4\. Folder Structure**
------------------------

my-node-app/
‚îÇ‚îÄ‚îÄ Dockerfile
‚îÇ‚îÄ‚îÄ package.json
‚îÇ‚îÄ‚îÄ package-lock.json
‚îî‚îÄ‚îÄ server.js
 `

**5\. Building & Running the Dockerfile**
-----------------------------------------

### **Step 1 ‚Äî Build the Docker Image**

```YAMLXML
docker build -t my-node-app .  
```

*   \-t my-node-app ‚Üí Tags the image with the name **my-node-app**.
*   ‚Üí Uses the current directory where the Dockerfile is located.
    

### **Step 2 ‚Äî Run the Docker Container**

```YAMLXML
docker run -d -p 3000:3000 --name myapp my-node-app 
```

*   \-d ‚Üí Run in detached mode.
*   \-p 3000:3000 ‚Üí Map **host port 3000** ‚Üí **container port 3000**.
*   \--name myapp ‚Üí Name the container **myapp**.
*   my-node-app ‚Üí The image to run.
    

### **Step 3 ‚Äî Verify the Running Container**

```YAMLXML
docker ps   `
```

It will show something like:
```yaml 
CONTAINER ID     IMAGE          STATUS             PORTS                  NAMES
abc1234        my-node-app    Up 5 secs     0.0.0.0:3000->3000/tcp        myapp
```


**6\. Quick Notes**
-------------------

*   A **Dockerfile** always starts with FROM to define a base image.
*   You can use **multiple RUN commands**, but fewer layers = better performance.
*   Use .dockerignore to exclude unnecessary files (like node\_modules).
*   Always optimize image size by using lightweight base images like alpine.
    

**7\. Summary**
---------------
*   **Dockerfile** ‚Üí Blueprint to build Docker images.
*   Contains instructions like **FROM, RUN, COPY, EXPOSE, CMD, etc.**
*   Used to **automate container creation**.
*   Once built, you can run, scale, and deploy containers easily.
    

**üê≥ Docker Networking ‚Äì Complete Guide**

**1\. What is Docker Networking?**
----------------------------------

Docker networking allows **containers to communicate**:

*   **With each other** (container-to-container)
*   **With the host machine**
*   **With the outside world (Internet)**
    

By default, Docker creates a **virtual network bridge** and assigns **private IP addresses** to containers.

**2\. Types of Docker Networks**
--------------------------------

Docker supports **five main network drivers**:

| **Network Type**       | **Description**                                                                                                | **Use Case**                                                                             |
| ---------------------- | -------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| **bridge** *(default)* | Creates a private internal network on the host. Containers can communicate using container names or IPs.       | Best for **standalone apps** on a single host.                                           |
| **host**               | Shares the **host machine‚Äôs network stack** with the container. No private IP; uses the host‚Äôs IP.             | Best for **high-performance apps** where you need **direct network access**.             |
| **none**               | Completely **disables networking** for the container.                                                          | Best for **security** or **offline** containers.                                         |
| **overlay**            | Allows communication **across multiple Docker hosts** (used in Swarm).                                         | Best for **Docker Swarm** or **multi-node** clusters.                                    |
| **macvlan**            | Assigns a **unique MAC address** to containers so they appear as **separate physical devices** on the network. | Best for **advanced networking setups** requiring containers to look like real machines. |

**3\. Default Docker Network Behavior**
---------------------------------------

When you install Docker:

*   A default network called **bridge** is created.
*   If you don't specify a network, containers connect to **bridge** automatically.
*   docker network lsOutput:NETWORK ID NAME DRIVER SCOPE4d3f2a3b2c1 bridge bridge localb8c1d2e3f4g host host local7f8g9h0i1j2 none null local
    

**4\. Docker Network Commands**
-------------------------------

### **4.1. List All Networks**

```YAMLXML
docker network ls   `
```
üìå Shows all networks on the system.

### **4.2. Inspect a Network**

```YAMLXML
docker network inspect bridge   `
```
üìå Displays **detailed info** about a network, including:

*   Connected containers
*   Subnet
*   Gateway
*   Driver
    

### **4.3. Create a Custom Network**

```YAMLXML
docker network create mynetwork   `
```
üìå Creates a custom network called **mynetwork** (default driver = **bridge**).

### **4.4. Run a Container on a Specific Network**

```YAMLXML
docker run -d --name mycontainer --network mynetwork nginx   `
```

üìå Launches a container attached to the **mynetwork** network.

### **4.5. Connect an Existing Container to a Network**

```YAMLXML
docker network connect mynetwork mycontainer   `
```
üìå Attaches **mycontainer** to the **mynetwork** network.

### **4.6. Disconnect a Container from a Network**

```YAMLXML
docker network disconnect mynetwork mycontainer   `
```
üìå Detaches **mycontainer** from **mynetwork**.

### **4.7. Remove a Network**

```YAMLXML
docker network rm mynetwork   
```
üìå Deletes the **mynetwork** network.

### **4.8. Remove All Unused Networks**

```YAMLXML
docker network prune   `
```
üìå Cleans up all unused networks.

**5\. Networking Examples**
---------------------------

### **Example 1 ‚Äî Two Containers Communicating**

```yaml
docker network create myappnet
docker run -d --name db --network myappnet mysql
docker run -d --name app --network myappnet nginx
```
Both db and app containers share myappnet.They can communicate using container names:

```bash
ping db
 ```   

### **Example 2 ‚Äî Using Host Network**

```YAMLXML
docker run -d --network host nginx 
```

*   Nginx runs **directly** on the host network.
*   Access it using:http://localhost:80
    

**6\. Quick Summary Table**
---------------------------

| **Command**                     | **Description**                         | **Example**                                   |
| ------------------------------- | --------------------------------------- | --------------------------------------------- |
| `docker network ls`             | List all networks                       | `docker network ls`                           |
| `docker network inspect <name>` | Show network details                    | `docker network inspect bridge`               |
| `docker network create <name>`  | Create a custom network                 | `docker network create mynet`                 |
| `docker run --network <name>`   | Run container on a network              | `docker run -d --network mynet nginx`         |
| `docker network connect`        | Connect existing container to a network | `docker network connect mynet mycontainer`    |
| `docker network disconnect`     | Disconnect container from a network     | `docker network disconnect mynet mycontainer` |
| `docker network rm <name>`      | Remove a network                        | `docker network rm mynet`                     |
| `docker network prune`          | Remove all unused networks              | `docker network prune`                        |


**7\. Key Takeaways**
---------------------
*   **Docker networks** enable container-to-container and container-to-host communication.
*   **Types of networks** ‚Üí bridge (default), host, none, overlay, macvlan.
*   Use docker network commands to **create, manage, and delete** networks.
*   For **multi-container applications**, **custom bridge networks** are best.
*   For **multi-host clusters**, use **overlay networks**.
    

**üê≥ Exposing Ports in Docker**

When you run a container, by default **its ports are isolated** and **cannot be accessed** from outside the container. To make a container accessible from your **host machine** or **external systems**, you need to **expose** or **publish** its ports.

**1\. Methods to Expose Ports**
-------------------------------

There are **two main ways** to expose a container port:

### **A. Using -p or --publish (Recommended)**

Maps a **container port** to a **host port**.

**Syntax:**

```YAMLXML
docker run -d -p 

**Example:**

```YAMLXML  
docker run -d -p 8080:80 nginx
```

*   **80** ‚Üí Default Nginx port **inside the container**
*   **8080** ‚Üí Port exposed **on your host machine**
    

**Access URL:**

```YAMLXML
http://localhost:8080  
```

### **B. Using -P (Publish All Exposed Ports Automatically)**

Maps **all container-exposed ports** to **random host ports**.

**Example:**

```YAMLXML
docker run -d -P nginx   `
```
To check which random ports are mapped:

```YAMLXML
docker ps   `
```
Output example:

```YAMLXML
CONTAINER_ID   IMAGE        PORTS  
2d3f4g5h6i7j   nginx   0.0.0.0:32771->80/tcp   `
```
Here, port **32771** on the **host** maps to port **80** inside the container.

**2\. Exposing Ports in a Dockerfile**
--------------------------------------

You can also expose ports **inside the Dockerfile** using the **EXPOSE** instruction.

**Example Dockerfile:**

```YAMLXML
FROM nginx:latest  
EXPOSE 80  
EXPOSE 443   `
```
**Build the image:**

```YAMLXML
docker build -t mynginx .   `
```
**Run the container:**

```YAMLXML
docker run -d -p 8080:80 -p 8443:443 mynginx   `
```
> **Note**: EXPOSE **does not actually publish the port**; it just acts as **documentation**.You **still need** to use -p or -P when running the container.

**3\. Check Mapped Ports**
--------------------------

### **A. Using docker ps**

```YAMLXML
docker ps
```

Example Output:

```YAMLXML
CONTAINER_ID   IMAGE         PORTS  
ab12cd34ef56   nginx     0.0.0.0:8080->80/tcp 
```

### **B. Using docker port**

```YAML
docker port 
```

Example:

```YAMLXML
docker port mynginx   `
```
Output:

```YAML
80/tcp -> 0.0.0.0:8080   `
```
**4\. Common Port Mapping Examples**
------------------------------------

| **Application** | **Container Port** | **Host Port Example** | **Command**                           |
| --------------- | ------------------ | --------------------- | ------------------------------------- |
| **Nginx**       | 80                 | 8080                  | `docker run -d -p 8080:80 nginx`      |
| **Apache**      | 80                 | 8081                  | `docker run -d -p 8081:80 httpd`      |
| **MySQL**       | 3306               | 3307                  | `docker run -d -p 3307:3306 mysql`    |
| **PostgreSQL**  | 5432               | 5433                  | `docker run -d -p 5433:5432 postgres` |
| **Redis**       | 6379               | 6380                  | `docker run -d -p 6380:6379 redis`    |


**5\. Quick Summary Table**
---------------------------

| **Option**    | **Description**                      | **Example**                   |
| ------------- | ------------------------------------ | ----------------------------- |
| `-p`          | Maps a host port to a container port | `docker run -p 8080:80 nginx` |
| `-P`          | Publishes all exposed ports randomly | `docker run -P nginx`         |
| `EXPOSE`      | Documents ports inside Dockerfile    | `EXPOSE 80`                   |
| `docker ps`   | View mapped ports                    | `docker ps`                   |
| `docker port` | Check specific container's ports     | `docker port mycontainer`     |


**6\. Key Takeaways**
---------------------

*   Use -p HOST:CONTAINER to expose a specific port.
*   Use -P to expose all ports automatically.
*   Use EXPOSE in Dockerfile for documentation.
*   Check exposed ports using docker ps or docker port.
    

**üê≥ Passing Arguments in Dockerfile (ARG & ENV)**

In Docker, we use the **ARG** instruction to define **build-time variables** that we can pass when building the image using docker build.After building the image, you can **run the container** and verify the arguments.

**1\. Using ARG in Dockerfile**
-------------------------------

The **ARG** instruction lets you define variables that users can pass at **build time** using --build-arg.

### **Example: Dockerfile**

##### # Base image
FROM alpine:latest

##### # Declare build-time argument
ARG USERNAME=defaultuser

##### # Use the argument in the image
RUN echo "Hello, ${USERNAME}!"

##### # Set environment variable from ARG
ENV FINAL_USER=$USERNAME

##### #Default command
CMD ["sh"]
   `

**2\. Building the Image with --build-arg**
-------------------------------------------

```YAMLXML
docker build -t myimage --build-arg USERNAME=nagendra .   `
```
### **How it works**

*   \--build-arg USERNAME=nagendra ‚Üí Passes the value **nagendra** to the Dockerfile.
*   Inside the Dockerfile, ${USERNAME} will be replaced with **nagendra**.
*   The environment variable FINAL\_USER will also be set to **nagendra**.
    

**3\. Running the Container**
-----------------------------

After building, run the image as a container:

```YAMLXML
docker run -it myimage   `
```
Inside the container, check the value of the environment variable:

```YAMLXML
echo $FINAL_USER   `
```
**Output:**

```YAMLXML
nagendra   `
```
**4\. Using Multiple Arguments**
--------------------------------

You can define multiple ARG instructions in the Dockerfile:

FROM ubuntu:latest

#### Define multiple arguments
ARG APP_NAME=myapp
ARG APP_ENV=dev

#### Use arguments
RUN echo "Building ${APP_NAME} in ${APP_ENV} mode"

**Build the image:**
```bash
docker build -t customapp \\
  --build-arg APP_NAME=docker-demo \\
  --build-arg APP_ENV=production 
```


**5\. Difference Between ARG and ENV**
--------------------------------------


| **Feature**       | **ARG** (Build-Time)          | **ENV** (Run-Time)                 |
| ----------------- | ----------------------------- | ---------------------------------- |
| **When Used**     | During **image build**        | During **container run**           |
| **Scope**         | Only available while building | Available **inside the container** |
| **Default Value** | Can have defaults             | Can have defaults                  |
| **Pass via CLI**  | `--build-arg NAME=value`      | `-e NAME=value` in `docker run`    |
| **Example**       | `ARG VERSION=1.0`             | `ENV VERSION=1.0`                  |


**6\. Overriding Arguments and Environment Variables**
------------------------------------------------------

If you want to **override an ENV variable** at **runtime**, use:
```YAMLXML
docker run -e FINAL_USER=rahul myimage
```

Then, inside the container:

```YAMLXML
echo $FINAL_USER   `
```
**Output:**

```YAMLXML
rahul   `
```
**7\. What to Do After Running the Dockerfile**
-----------------------------------------------

Once you **write the Dockerfile** and **pass arguments**, here‚Äôs the workflow:

### **Step 1 ‚Äî Build the Image**

```YAMLXML
docker build -t myapp --build-arg USERNAME=nagendra
```
### **Step 2 ‚Äî Verify the Image**

```YAMLXML
docker images   `
```
### **Step 3 ‚Äî Run the Container**

```YAMLXML   
docker run -it myapp   `
```
### **Step 4 ‚Äî Verify Inside the Container**

```  
echo $FINAL_USER   `
```
**8\. Quick Summary Table**
---------------------------

| **Command**   | **Description**                           | **Example**                            |
| ------------- | ----------------------------------------- | -------------------------------------- |
| `ARG`         | Define build-time variables in Dockerfile | `ARG VERSION=1.0`                      |
| `--build-arg` | Pass value during `docker build`          | `docker build --build-arg VERSION=2.0` |
| `ENV`         | Define runtime environment variables      | `ENV APP_NAME=myapp`                   |
| `-e`          | Override env variable at runtime          | `docker run -e APP_NAME=demo myimage`  |
| `echo $VAR`   | Check value inside container              | `echo $FINAL_USER`                     |


**9\. Key Takeaways**
---------------------

*   Use **ARG** for **build-time variables**.
    
*   Use **ENV** for **run-time variables**.
    
*   You can combine both:**Set ARG ‚Üí Use it to define ENV ‚Üí Access inside container**.
    
*   Always verify values inside the container using echo.
    

**üê≥ Difference Between docker attach and docker exec**

When working with **Docker containers**, we often need to **interact** with running containers.Two common commands for this are **docker attach** and **docker exec**, but they behave differently.

**1\. docker attach** ‚Üí _Attach to Main Process_
------------------------------------------------

*   Connects your terminal **directly** to the **main process** of the container.
*   You see the **same output** as the container's primary process.
*   If you **exit** using Ctrl+C or Ctrl+D, it **stops the container** (unless the process is running in detached mode).
*   Not suitable when you want to **run extra commands** inside the container.
    

### **Example**

```  
docker run -it --name mycontainer ubuntu
```

Inside the container:

```   
root@container:/# echo "Hello"  Hello   `
```
Now, **detach** from it without stopping:

```   
Ctrl+P Ctrl+Q   `
```
Re-attach:

```YAMLXML   
docker attach mycontainer   `
```
**2\. docker exec** ‚Üí _Run Commands in Running Containers_
----------------------------------------------------------

*   Lets you **run a new command** in a **running container** without attaching to its main process.
*   It **doesn't affect** the container‚Äôs main process.
*   Safer than docker attach because you can **open a separate shell**.
*   Mostly used to **debug containers** or **inspect environments**.
    

### **Example**

```YAMLXML
docker exec -it mycontainer /bin/bash   `
```
Inside the container:

```YAMLXML
root@container:/# ls 
/  bin  boot  dev  etc  home `
```
You can exit this shell:

```YAMLXML
exit   `
```
The container **keeps running** in the background.

**3\. Side-by-Side Comparison**
-------------------------------

| **Feature**                 | **`docker attach`**                        | **`docker exec`**                       |
| --------------------------- | ------------------------------------------ | --------------------------------------- |
| **Purpose**                 | Attach to container‚Äôs **main process**     | Run a **new process** inside container  |
| **Starts a New Shell**      | ‚ùå No                                       | ‚úÖ Yes                                   |
| **Stops Container on Exit** | ‚úÖ Yes (if you exit using Ctrl+C)           | ‚ùå No                                    |
| **Recommended For**         | Monitoring the container‚Äôs default process | Running commands or debugging           |
| **Multiple Terminals**      | ‚ùå Not supported                            | ‚úÖ Supported                             |
| **Example**                 | `docker attach mycontainer`                | `docker exec -it mycontainer /bin/bash` |


**4\. Best Practices**
----------------------

*   Use **docker exec** when you want to **debug**, **inspect**, or **run additional commands** in the container.
*   Use **docker attach** only when you **want to see the container‚Äôs main process output**.
*   Always detach safely using:
    

```YAMLXML
Ctrl+P Ctrl+Q   `
```
to avoid stopping the container.

**5\. Quick Examples**
----------------------

#### **Attach to a Running Container**

```YAMLXML
docker attach mycontainer   `
```
### **Run a Command in a Running Container**

```YAMLXML
docker exec -it mycontainer ls /app   `
```
### **Start a New Shell in the Container**

```YAMLXML
docker exec -it mycontainer /bin/bash   `
```
**Summary**
-----------

*   docker attach ‚Üí Joins you to the **container‚Äôs main process**. Exiting can **stop the container**.
*   docker exec ‚Üí Opens a **new shell or process** inside the container without affecting the main process
*   **Recommendation** ‚Üí Use **exec** for debugging; use **attach** for monitoring logs or container output.
